import { isArray, isEmpty, isUsable } from 'af-conditionals';
import waitUntil from 'async-wait-until';

import { Entity, EntityOptions } from '..';
import { Normalizer } from './normalizers';
import {
  DEFAULT_INVALID_IF_NOT_REQUIRED_AND_EMPTY,
  DEFAULT_NORMALIZE_AFTER_SET,
  DEFAULT_NORMALIZE_BEFORE_VALIDATE,
  DEFAULT_NORMALIZE_IF_VALID,
  DEFAULT_PROPERTY_VALIDATION_WAIT_INTERVAL,
  DEFAULT_PROPERTY_VALIDATION_WAIT_TIMEOUT,
  DEFAULT_REQUIRED,
  PROPERTY_NORMALIZE_EVENT,
  PROPERTY_VALIDATION_CACHED_EVENT,
  PROPERTY_VALIDATION_EVENT,
  PROPERTY_VALUE_SET_EVENT,
  PropertyValidationEvent,
  PropertyValueChangeEvent,
} from './property-defs';
import { RequiredValidator, Validator, ValidatorError } from './validators';

/**
 * PropertyOptions provides options for the Property base class.
 *
 * @export
 * @interface PropertyOptions
 * @extends {EntityOptions}
 */
export interface PropertyOptions extends EntityOptions {
  /**
   * When messages or events are generated by a Property the displayName is
   * used to provide a contextual name for the message or event.
   *
   * @type {string}
   * @memberof PropertyOptions
   */
  displayName?: string;

  /**
   * When validating a Property, this boolean value will indicate if a value is
   * invalid when it is empty (doesn't have a value) and it is not required.
   *
   * @type {boolean}
   * @memberof PropertyOptions
   */
  invalidIfNotRequiredAndEmpty?: boolean;

  /**
   * This is the internal name of the Property. This is used to "find" the
   * Property in certain situations and is used as the displayName if one is
   * not provided. Additionally, name will be assigned a generic name if it is
   * not provided.
   *
   * @type {string}
   * @memberof PropertyOptions
   */
  name: string;

  /**
   * normalizeAfterSet is a boolean flag that will trigger the Property to be
   * automatically normalized when a value is set. This make it very convenient
   * to keep a value normalized.
   *
   * @type {boolean}
   * @memberof PropertyOptions
   */
  normalizeAfterSet?: boolean;

  /**
   * normalizeBeforeValidate is a boolean flag that will trigger the Property
   * to be normalized prior to validation.
   *
   * @type {boolean}
   * @memberof PropertyOptions
   */
  normalizeBeforeValidate?: boolean;

  /**
   * normalizeIfValid is a boolean flag that will trigger the Property value
   * to be normalized after the validation process, if the value is valid.
   *
   * @type {boolean}
   * @memberof PropertyOptions
   */
  normalizeIfValid?: boolean;

  /**
   * required is a boolean flag that determines if the Property value is
   * required or not. By default all Properties have the {RequiredValidator}.
   * This value will indicate to the {RequiredValidator} how it should behave.
   *
   * @type {boolean}
   * @memberof PropertyOptions
   */
  required?: boolean;
}

export const DEFAULT_PROPERTY_OPTIONS: Readonly<PropertyOptions> = {
  displayName: '',
  invalidIfNotRequiredAndEmpty: DEFAULT_INVALID_IF_NOT_REQUIRED_AND_EMPTY,
  name: '',
  normalizeAfterSet: DEFAULT_NORMALIZE_AFTER_SET,
  normalizeBeforeValidate: DEFAULT_NORMALIZE_BEFORE_VALIDATE,
  normalizeIfValid: DEFAULT_NORMALIZE_IF_VALID,
  required: DEFAULT_REQUIRED,
  validationWaitInterval: DEFAULT_PROPERTY_VALIDATION_WAIT_INTERVAL,
  validationWaitTimeout: DEFAULT_PROPERTY_VALIDATION_WAIT_TIMEOUT,
};

/**
 * The Property object provides a class that can normalize and validate values
 * in a consistent way. Through this consistent interface Properties can take
 * part in larger structures such as documents. Advanced Property types have
 * been taken into consideration, such as validations that required access to
 * external web services. The property class uses an Event emitting mechanism
 * to allow listeners to react to changes within the Property.
 *
 * @export
 * @class Property
 * @extends {Entity<T, O>}
 * @template T
 * @template O
 */
export class Property<
  T = any,
  O extends PropertyOptions = PropertyOptions
> extends Entity<T, O> {
  /**
   * Class method to retrieve the next propertyCount value.
   *
   * @static
   * @returns {number}
   * @memberof Property
   */
  public static getNextPropertyCount(): number {
    return ++Property.propertyCount;
  }

  /**
   * Class method to retrieve the current propertyCount value.
   *
   * @static
   * @returns {number}
   * @memberof Property
   */
  public static getPropertyCount(): number {
    return Property.propertyCount;
  }

  /**
   * propertyCount is a class value that counts the number of properties
   * instantiated. This value is used to assign property names to properties
   * that do not assign their own names.
   *
   * @protected
   * @static
   * @type {number}
   * @memberof Property
   */
  protected static propertyCount = 0;

  /**
   * normalized indicates if the current value has a normalized value or not.
   *
   * @protected
   * @type {boolean}
   * @memberof Property
   */
  protected normalized = false;

  /**
   * valid indicates if the current value has a valid value or not. The
   * value of valid is only considered properly set if validated is true.
   *
   * @protected
   * @type {boolean}
   * @memberof Property
   */
  protected valid = false;

  /**
   * validated indicates that the current value property has been checked via
   * the isValid method. A true value for this property indicates that the
   * current value has been validated and a false value indicates that the
   * current value has not been validated. The reset method resets this value
   * to false. reset is called each time the data property is changed.
   *
   * @protected
   * @type {boolean}
   * @memberof Property
   */
  protected validated = false;

  /**
   * Creates an instance of Property.
   *
   * @param {T} newValue - the value to assign the data property.
   * @param {O} newOptions - a PropertyOptions value with values that describe
   * this property and how it should function.
   * @param {Normalizer<T>[]} [normalizers=[]] - an array of Normalizers that
   * will be executed on this Property when the normalize method is called.
   * @param {Validator<T>[]} [validators=[]] - an array of Validators that will
   * be executed on this Property when this validate method is called.
   * @memberof Property
   */
  constructor(
    newValue: T,
    newOptions: O,
    protected normalizers: Normalizer<T>[] = [],
    protected validators: Validator<T>[] = []
  ) {
    super(newOptions);

    if (!isArray(this.normalizers) || this.normalizers.length === 0) {
      this.initDefaultNormalizers();
    }
    if (!isArray(this.validators) || this.validators.length === 0) {
      this.initDefaultValidators();
    }

    this.value = newValue;
  }

  /**
   * This getter will return the current value of the Property.
   *
   * @type {(T | undefined)}
   * @memberof Property
   */
  public get value(): T | undefined {
    return this.data;
  }

  /**
   * This setter will set the value of the Property. The setter first determines
   * if the supplied value is allowed to be set for this Property by using the
   * isValueAllowed method. The setter then determines if the newValue is equal
   * to the current value using the isEqual method. Next, if the setter
   * determines the newValue is different from the current value the Property
   * tracking values are reset (using the reset method) and then an event is
   * emitted so any listeners will be aware of the Property value change.
   * Finally, if the normalizeAfterSet option is set to true the new value will
   * be normalized using the normalize method.
   *
   * @memberof Property
   */
  public set value(newValue: T | undefined) {
    if (!this.isValueAllowed(newValue)) {
      throw new Error(this.options.displayName + ' is not an allowed value.');
    }
    if (this.isEqual(newValue!)) return;

    const previousValue = this.data;
    this._setValue(newValue);
    this.reset();
    this.emitValueChanged(PROPERTY_VALUE_SET_EVENT, previousValue);
    if (this.options.normalizeAfterSet) this.normalize();
  }

  /**
   * Retrieve the current errors based upon the last validate execution.
   *
   * @returns {ValidatorError[]}
   * @memberof Property
   */
  public getErrors(): ValidatorError[] {
    let allErrors: ValidatorError[] = [];
    this.validators.forEach((validator: Validator<T>) => {
      const validatorErrors = validator.getErrors();
      allErrors = allErrors.concat(validatorErrors);
    });
    return allErrors;
  }

  /**
   * Return the name value set in options.
   *
   * @returns {string}
   * @memberof Property
   */
  public getName(): string {
    return this.options.name;
  }

  /**
   * Returns true if the Property value "equals" otherValue. Equals is in quotes
   * since this method can be written to your needs and therefore may not always
   * be a strict exact equals.
   *
   * @param {T} otherValue
   * @returns {boolean}
   * @memberof Property
   */
  public isEqual(otherValue: T): boolean {
    return this.value === otherValue;
  }

  /**
   * Returns if the current value of this Property has been normalized. This
   * will be reset to false whenever you set the value of this Property to
   * something new.
   *
   * @returns {boolean}
   * @memberof Property
   */
  public isNormalized(): boolean {
    return this.normalized;
  }

  /**
   * Returns true if the options for this Property indicate the Property's
   * value must be a non-empty value.
   *
   * @returns {boolean}
   * @memberof Property
   */
  public isRequired(): boolean {
    return this.options.required!;
  }

  /**
   * Returns the current status of the valid state for this Property. This will
   * be reset to false whenever you set the value of this Property to something
   * new.
   *
   * @returns {boolean}
   * @memberof Property
   */
  public isValid(): boolean {
    return this.valid;
  }

  /**
   * Perform normalization on the value of this Property. Normalization is
   * performed by {Normalizer} objects. After all normalizers have run we
   * emit an PROPERTY_NORMALIZE_EVENT with the previous value of the Property.
   *
   * @returns {void}
   * @memberof Property
   */
  public normalize(): void {
    if (
      this.isNormalizing() ||
      this.isNormalized() ||
      (this.isValid() && !this.options.normalizeIfValid)
    ) {
      return;
    }

    const previousValue = this.value;

    // We use a flag to indicate if we are normalizing or not. We do this
    // because by setting our new value to this Property using this.value we
    // could call this.normalize again if options.normalizeAfterSet is set
    // to true.
    this.normalizing = true;
    try {
      this.normalizers.forEach((normalizer: Normalizer<T>) => {
        this.value = normalizer.normalize(this.value!);
      });
    } finally {
      this.normalizing = false;
    }
    this.normalized = true;
    this.emitValueChanged(PROPERTY_NORMALIZE_EVENT, previousValue);
  }

  /**
   * Resets the tracking values for this Property. Effectively, makes the
   * Property look as if it has not been normalized or validated.
   *
   * @memberof Property
   */
  public reset(): void {
    this.validators.forEach((validator: Validator<T>) => {
      validator.reset();
    });
    this.normalized = false;
    this.valid = false;
    this.validated = false;
  }

  /**
   * Return the string representation of this Property. The Property value will
   * be normalized first.
   *
   * @returns {string}
   * @memberof Property
   */
  public toString(): string {
    this.normalize();
    return String(this.value);
  }

  /**
   * Validate the property using {Validator} objects. If the Property has
   * already been validated this method will return early and a
   * PROPERTY_VALIDATION_CACHED_EVENT will be emitted. If the Property needs to
   * be validated, the value will first be normalized if the
   * options.normalizeBeforeValidate is set to true. This method then uses the
   * protected method _validate to perform the actual validation.
   *
   * @returns {Promise<boolean>}
   * @memberof Property
   */
  public async validate(): Promise<boolean> {
    if (this.validating) {
      throw new Error(
        'You have called validate() while another' +
          ' validate() call is running.'
      );
    }
    if (this.validated) {
      this.emitValidated(PROPERTY_VALIDATION_CACHED_EVENT, this.valid);
      return Promise.resolve(this.valid);
    }

    try {
      // Make sure we don't allow another call to isValid() while we are
      // processing this isValid() run
      this.validating = true;

      if (this.options.normalizeBeforeValidate) this.normalize();

      return await this._validate();
    } finally {
      this.validating = false;
    }
  }

  /**
   * Returns the Property value. This method allows Property objects to be used
   * in normal JavaScript operation (e.g. + for strings, +-/* for numbers, etc).
   *
   * @returns {T}
   * @memberof Property
   */
  public valueOf(): T | undefined {
    this.normalize();
    return this.value;
  }

  protected _setValue(newValue: T | undefined): void {
    this.data = newValue;
  }

  /**
   * Emit a validated event.
   *
   * @protected
   * @param {string} eventId
   * @param {boolean} validated
   * @memberof Property
   */
  protected emitValidated(eventId: string, validated: boolean): void {
    const event: PropertyValidationEvent<T> = {
      context: this,
      displayName: this.options.displayName!,
      name: this.options.name,
      validated,
      value: this.value!,
    };
    this.emit(eventId, event, this);
  }

  /**
   * Emit the previous value of this Property.
   *
   * @protected
   * @param {string} eventId
   * @param {(T | undefined)} previousValue
   * @memberof Property
   */
  protected emitValueChanged(
    eventId: string,
    previousValue: T | undefined
  ): void {
    const event: PropertyValueChangeEvent<T> = {
      context: this,
      displayName: this.options.displayName!,
      name: this.options.name,
      previousValue,
      value: this.value!,
    };
    this.emit(eventId, event, this);
  }

  /**
   * Initialize the default {Normalizer} objects. This Property sets this to an
   * empty array.
   *
   * @protected
   * @memberof Property
   */
  protected initDefaultNormalizers(): void {
    this.normalizers = [];
  }

  /**
   * Initialize the default {Validator} objects. This Property only creates a
   * {RequiredValidator}.
   *
   * @protected
   * @memberof Property
   */
  protected initDefaultValidators(): void {
    this.validators = [];

    // We always require the RequiredValidator because...
    // 1. We now have a validator that can answer the isValueAllowed
    //    question
    // 2. The RequiredValidator is written to even handle when a
    //    value is NOT required.
    this.validators.push(
      new RequiredValidator<T>({ parent: this })
    );
  }

  /**
   * Use the list of validators and ask each one if the value is allowed for
   * this Property or not.
   *
   * @protected
   * @param {(T | undefined)} newValue
   * @returns {boolean}
   * @memberof Property
   */
  protected isValueAllowed(newValue: T | undefined): boolean {
    let allowed = true;
    for (const validator of this.validators) {
      allowed = validator.isValueAllowed(newValue);
      if (!allowed) break;
    }
    return allowed;
  }

  /**
   * Validate our Property value. This method implements an asynchronous
   * validation process. Currently the validators are run in the order they are
   * presented in the validators array. By default all validators will be
   * run to determine the validated state of this Property. If
   * options.stopValidationOnInvalid is set to true, upon the first
   * validator that returns false the validation process will cease. Upon
   * completion of the validation process a PROPERTY_VALIDATION_EVENT will
   * be emitted with the results.
   *
   * @protected
   * @returns {Promise<boolean>}
   * @memberof Property
   */
  protected async _validate(): Promise<boolean> {
    let loopValid = true;
    for (const validator of this.validators) {
      // Since a validator could be validating due to other causes,
      // we must test here to ensure we don't call the validation
      // while it is currently running.
      await waitUntil(
        (): boolean => {
          return !validator.isValidating();
        },
        this.options.validationWaitTimeout,
        this.options.validationWaitInterval
      );

      const _valid = await validator.validate(this.value!);

      if (loopValid && !_valid) {
        loopValid = false;
        // By iterating through all of the validators we collect
        // possible errors before returning. If
        // stopValidationOnInvalid is true then we exit early.
        if (this.options.validationStopOnInvalid) break;
      }
    }
    // We do not want to change valid inside our loop since it
    // is asynchronous, this ensures that we don't provide false
    // positives or negatives
    this.valid = loopValid;
    this.validated = true;

    this.emitValidated(PROPERTY_VALIDATION_EVENT, this.valid);

    return Promise.resolve(this.valid);
  }

  /**
   * Ensure that our options property has valid values.
   *
   * @protected
   * @param {O} newOptions
   * @memberof Property
   */
  protected _validateOptions(newOptions: O): void {
    if (!isUsable(newOptions.name) || isEmpty(newOptions.name)) {
      throw new TypeError('Must supply a valid options object.');
    }
    // We override values that Entity is responsible for,
    // validationWaitInterval and validationWaitTimeout. Therefore, we must
    // ensure that we have valid values here BEFORE Entity applies its own
    // defaults.
    if (!isUsable(newOptions.validationWaitInterval)) {
      newOptions.validationWaitInterval = DEFAULT_PROPERTY_VALIDATION_WAIT_INTERVAL;
    }
    if (!isUsable(newOptions.validationWaitTimeout)) {
      newOptions.validationWaitTimeout = DEFAULT_PROPERTY_VALIDATION_WAIT_TIMEOUT;
    }
    super._validateOptions(newOptions);

    this.options.displayName = this.options.displayName || this.options.name;
    if (!isUsable(this.options.invalidIfNotRequiredAndEmpty)) {
      this.options.invalidIfNotRequiredAndEmpty = DEFAULT_INVALID_IF_NOT_REQUIRED_AND_EMPTY;
    }
    if (!isUsable(this.options.normalizeAfterSet)) {
      this.options.normalizeAfterSet = DEFAULT_NORMALIZE_AFTER_SET;
    }
    if (!isUsable(this.options.normalizeBeforeValidate)) {
      this.options.normalizeBeforeValidate = DEFAULT_NORMALIZE_BEFORE_VALIDATE;
    }
    if (!isUsable(this.options.normalizeIfValid)) {
      this.options.normalizeIfValid = DEFAULT_NORMALIZE_IF_VALID;
    }
    if (!isUsable(this.options.required)) {
      this.options.required = DEFAULT_REQUIRED;
    }
  }
}
